## 静态代理(在代码中显式指定的代理)
1. 首先定义一个接口，说明业务逻辑。  
2. 定义业务实现类，实现接口
3. 定义业务代理类：通过组合，在代理类中创建一个业务实现类对象来调用具体的业务方法；通过实现业务逻辑接口，来统一业务方法；在代理类中实现业务逻辑接口中的方法时，进行预处理操作、通过业务实现类对象调用真正的业务方法、进行调用后操作的定义。
4. 在使用时，首先创建业务实现类对象，然后把业务实现类对象作构造参数创建一个代理类对象，最后通过代理类对象进行业务方法的调用。

 静态代理的缺点很明显：一个代理类只能对一个业务接口的实现类进行包装，如果有多个业务接口的话就要定义很多实现类和代理类才行。而且，如果代理类对业务方法的预处理、调用后操作都是一样的（比如：调用前输出提示、调用后自动关闭连接），则多个代理类就会有很多重复代码。这时我们可以定义这样一个代理类，它能代理所有实现类的方法调用：根据传进来的业务实现类和方法名进行具体调用。——那就是动态代理。

---

## JDK动态代理
1. 首先，定义业务逻辑接口
2. 实现业务逻辑接口创建业务实现类
3. **实现 调用管理接口InvocationHandler。创建动态代理类**（前2步和静态代理一样，只有这一步不一样）

 这种动态代理要求实现类一定要实现某一接口，如果没有实现接口中的方法，则无法被代理

---

## CGLIB动态代理
1. 首先定义业务类，无需实现接口（当然，实现接口也可以，不影响的）
2. **实现 MethodInterceptor方法代理接口，创建代理类**
3. 创建业务类和代理类对象，然后通过  代理类对象.getInstance(业务类对象)  返回一个动态代理类对象（它是业务类的子类，可以用业务类引用指向它）。最后通过动态代理类对象进行方法调用。